# 模块
=======

您已经看到如何通过一次定义函数在程序中重用代码。如果你想在其它程序中重用一定数量的函数，你将写什么？正如你可能已经猜到了，答案是模块。

编写模块有各种各样的方法，但是最简单的方法是创建一个以.py 为扩展名、包含函数和变量的文件。

编写模块的另一种方式是使用编写Python解释器本身的本机语言，例如，你可以使用[C 编程语言](http://docs.python.org/3/extending/index.html)编写模块，当它们被编译后，当使用标准的Python解释器时，在你Python代码中可以使用这些模块。

一个模块可以因另一个程序使用其功能而被*imported(导入)*。同样，我们可以使用Python标准库。首先 ,我们将看到如何使用标准库模块。

例子 (保存为 using_sys.py):

```
import sys

print('命令行参数是：')
for i in sys.argv:
    print(i)

print('\n\nPYTHONPATH在', sys.path, '\n')
```

输出:

```
D:> python using_sys.py we are arguments
命令行参数是
using_sys.py
we
are
arguments

PYTHONPATH在[<nowiki>''</nowiki>, 'C:\\Windows\\system32\\python30.zip',
'C:\\Python30\\DLLs', 'C:\\Python30\\lib',
'C:\\Python30\\lib\\plat-win', 'C:\\Python30', 
'C:\\Python30\\lib\\site-packages']
```

它是如何工作的:

首先,我们使用import语句import导入sys（系统）模块。基本上，这意味着我们我们想告诉Python，我们想使用这个模块。sys模块包含了与Python解释器和其环境即system系统有关的函数。

当Python执行import sys 语句时，它查找sys模块。在这里，它是一个内建模块，因此，Python知道到去哪里找到它。

如果它不是一个编译的，也就是用Python写的模块，那么，Python解释器将在sys.path变量列表中的目录中搜索。如果模块被发现，那么，模块中的代码将运行，对你来说，使用模块变为有效。注意，初始化只有在我们第一次导入一个模块时完成。

在sys模块中的argv变量是通过点符号访问的，例如，例如，sys.argv。它清楚地表明，这个名字是sys模块的一部分。这种方法的另一个优点是，这个名字与你的程序中使用的任何argv变量都不冲突。

sys.argv变量一个字符串list(列表)。具体来说，sys.argv包含命令行参数，也就是使用命令行向你的程序传递参数，的列表。

如果您正在使用IDE编写并运行这些程序，在菜单中寻找一种方法来指定命令行参数传递给你的程序。

这里，当我们执行python using_sys.py we are arguments时，我们使用 python命令和其后的传递给程序的参数运行using_sys.py模块。Python把命令行参数存储在 sys.argv变量中供我们使用。

记住，运行脚本的名字通常是sys.argv列表中的第一个参数。因此，在这里将有'using_sys.py'作为sys.argv[0]，'we'作为sys.argv[1]，'are'作为sys.argv[2]和'arguments'作为sys.argv[3]。注意，Python从0而不是1开始数数。

sys.path包含被导入的模块所在的目录名列表。观察到sys.path就是的第一个字符串是空的——这个空字符串表示当前目录是和PYTHONPATH环境变量相同的、sys.path变量的一部分。这意味着你可以直接导入位于当前目录中的模块。否则，你将不得不把你的模块存放在sys.path列表中的一个目录中。

请注意，,当前目录是程序启动的目录。运行import os; print(os.getcwd())找到你的程序的当前目录。

## 字节编译的.pyc文件

导入一个模块是一个相对昂贵的事情，所以Python做 了一些技巧使它更快。一种方法是创建扩展名为.pyc的字节编译文件，是Python将程序转换成的一种中间形式。(记得在Python如何工作的[简介部分)(#介绍))。当你下次从一个不同程序导入模块时，这种.pyc文件是有很用的--它将快得多，因为导入模块一部分需要的处理已经完成。同时，这些字节编译的文件是独立于平台的。

注意
> 这些.pyc文件通常在与之相应的.py文件的同一个目录中创建。如果Python在那个目录中没有写入权限，那么.pyc文件将不会创建。

## from ... import语句

如果你想直接导入argv变量到程序中(为了避免每次为它键入sys.)，那么您可以使用from sys import argv语句。

一般来说，你应该避免使用这个语句，而应该使用import语句，因为你的程序将避免名称冲突，将更具可读性。

例如：

```
from math import sqrt
print("16的平方根是", sqrt(16))
```

## 模块的name

每个模块都有一个名字，在模块中的语句能够找出它所在的模块的名字。这对于搞清楚模块是否正在运行或被导入这样的特殊用途是很方便的。正如前面提到的，当一个模块被第一次导入时，其所包含的代码被执行。我们可以通过使用这个，根据模块是否被自己使用或从另一个 模块被导入，使模块以不同的方式起作用，这些可以通过使用模块的 __name__属性来实现。

例子 (保存为 using_name.py):

```
if __name__ == '__main__':
    print('这个程序正在被自己运行')
else:
    print('我从别的模块被导入')
```

输出：

```
D:> python using_name.py
这个程序正在被自己运行
D:> python3
>>> import using_name
我从别的模块被导入
>>>
```

它是如何工作的：

每个Python模块有其__name__ 定义，如果是__name__ ，这意味着模块在被用户独立的运行，我们可以采取适当的行动。 ## 制作属于你自己的模块

创建自己的模块是很容易的，你一直在这样做，始终都是！这是因为每个Python程序也是一个模块。 你只需要确保它有一个.py扩展名。下面的例子会让你明白。

例子 (保存为mymodule.py):

```
def sayhi():
    print('嗨，这是我的模块在讲话。')

__version__ = '0.1'
```

上面的是模块的一个示例。正如您可以看到的，和我们通过的Python程序相比，没有什么特别的。接下来我们要看如何在我们的其它程序中使用这个模块。

记住,该模块要么放置在我们导入它的程序相同的目录中，要么放置在sys.path目录列表中的一个目录中。

另一个模块(保存为mymodule_demo.py):

```
import mymodule

mymodule.sayhi()
print ('版本', mymodule.__version__)
```

输出：

```
D:> python mymodule_demo.py
嗨，这是我的模块在讲话。
版本 0.1
```

它是如何工作的：

注意，我们使用相同的点符号来访问模块的成员。Python充分重用相同的符号产生了独特的'神谕的'的感觉，这样我们不需要不断学习新的方法来做事情。

这是使用from..import语法的一个版本(保存为mymodule_demo2.py):

```
from mymodule import sayhi, __version__

sayhi()
print('版本', __version__)
```

mymodule_demo2.py和mymodule_demo.py的输出相同。

注意，如果在导入模块中已经有一个__version__名字的声明，这里会有一个冲突。这也可能是因为它是常见的做法--对于每个模块使用这个名字声明它的版本号。因此，总是推荐选择import语句，虽然它可能让你的程序有点长。

你还可以使用：

```
from mymodule import *
```

这将导入所有的公共名称如 sayhi，但不会导入__version__，因为它始于双下划线。

Python的禅
> Python的一个指导原则是"显式优于隐式"。运行import this去学习更多，看[关于Python之禅的讨论](http://stackoverflow.com/questions/228181/zen-of-python)，那里列出了每个原则的例子。

## dir函数

您可以使用内置的dir函数列出一个定义对象的标识符。例如,对于一个模块，包括在模块中定义的函数，类和变量。

当你给dir()提供一个模块名字时，它返回在那个模块中定义的名字的列表。当没有为其提供参数时, 它返回当前模块中定义的名字的列表。

例如：

```
D:> python

>>> import sys # 获得属性列表，在这里是sys模块的属性列表

>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__', '__s
tderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_compact_freelists',
'_current_frames', '_getframe', 'api_version', 'argv', 'builtin_module_names', '
byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dllhandle'
, 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable',
'exit', 'flags', 'float_info', 'getcheckinterval', 'getdefaultencoding', 'getfil
esystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof',
'gettrace', 'getwindowsversion', 'hexversion', 'intern', 'maxsize', 'maxunicode
', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platfor
m', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setprofile', 'setrecursionlimit
', 'settrace', 'stderr', 'stdin', 'stdout', 'subversion', 'version', 'version_in
fo', 'warnoptions', 'winver']

>>> dir() # 获得当前模块的属性列表
['__builtins__', '__doc__', '__name__', '__package__', 'sys']

>>> a = 5 # 创建了一个新变量 'a'

>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'a', 'sys']

>>> del a # 删除/移除一个名字

>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'sys']

>>>
```

它是如何工作的：

首先，我们看到在导入sys模块上使用使用dir。我们能看到模块包含的巨大的属性列表。

然后，我们使用没有传递参数的dir函数。默认情况下，它返回模块的属性的列表。注意，导入模块的列表仍然是这个列表的一部分。

为了看到 dir在起作用，我们定义了一个新的变量，并为其赋值，然后检查dir，我们发现列表中添加了一个同名变量。我们使用del语句移除当前模块的变量或属性，在 del函数的输出中变化再次得到体现。

关于del的一点注意事项--这个语句用于删除一个变量/属性，语句运行后，这里是del a，你不能再访问变量a--就像它从来根本没有存在过。

注意，dir()函数对任何对象都起作用。例如，运行dir('print')来学习print函数的属性的更多知识，或运行dir(str)学习str类的属性的更多知识。

## 打包（封装）

现在，你必须开始观察组织你的程序的层次结构。变量通常在函数内部。函数和全局变量通常在模块内部。如果你想组织模块？这就到了牵涉到打包的地方了。

包只是模块的文件夹，使用一个特殊的__init__.py 文件，指示Python，这个文件夹是特殊的，因为它包含Python模块。

假设你想创建一个叫做'世界'的程序包，分装'亚洲'、'非洲'等等，分包按序包含'印度'、'马达加斯加'等等。

这是你将组织的文件夹： ~ - <在sys.path中现有的一些文件夹>/ - world/ - init.py - asia/ - init.py - india/ - init.py - foo.py - africa/ - init.py - madagascar/ - init.py - bar.py ~

包只是为了分层次组织模块的方便。在标准库中，你会看到包的许多实例。

## 小结

就像函数是可重用的部分的程序一样，模块也是可重用的程序。包是组织模块的另一个层次结构。来自Python的标准库，是包和模块的集合中的一个例子。

我们已经看到了如何使用这些模块和创建我们自己的模块。

接下来，我们将学习一些有趣的称为数据结构的概念。 # 数据结构

数据结构基本上是由于--他们是结构可将一些数据容纳在一起。换句话说，它们是用来存储一系列关的数据。

在Python中有四种 内建数据结构--列表、元组、字典和集合（set)，我们将看到如何使用它们中的每一个，它们是怎样使我们的生活更容易的。

## 列表

列表是一种数据结构，它保存条目的有序集合。例如，你可以在列表中存储一个序列。这很容易想象，你想像一下购物清单,那里有你要购买物品的一个清单。除非在你的清单上每一行列有一个单独物品，然而，在python中，你在它们中间放上逗号。

条目的列表应包含在方括号内，以便Python明白你在指定一个列表。一旦您创建了一个列表，你可以添加、删除或是搜索列表中的条目。因为我们可以添加和删除条目，我们说一个列表是一个可变的数据类型，即这种类型可以更改。

## 对象和类的快速介绍

尽管直到现在，我一直推迟讨论对象和类，现在需要一个小小的解释，这样你可以更好的理解列表。我们将在后面章节中详细探讨这一课题。

列表是使用对象和类的一个例子。当我们使用一个变量 i，为它分配一个值，例如把整数5赋值给它，你可以认为它是创建一个类为int（即类型）的对象(即实例)i。事实上，你可以阅读的help(int)更好地理解这一点。

类也有方法，也就是为了使用而定义的只关于那个类的函数，只有当你有那个类的对象时，你才可以使用这些函数.例如，Python为list（列表）类提供了一个append方法，它允许你在列表的整改添加一个条目。例如，mylist.append('an item')将给列表mylist添加字符串。注意，我们使用点操作符访问对象的方法。

类也有字段，除了为了使用而定义的只与那个类相关的变量，它什么也没有。只有当你有那个类的对象时，你可以使用那些变量或名字。字段孔明通过点操作符访问的。例如，mylist.field。

例子 (保存为using_list.py):

```
# 这是我的购物清单
shoplist = ['苹果', '芒果', '胡萝卜', '香蕉']

print('我要买', len(shoplist), '个物品。')

print('清单是：', end=' ')
for item in shoplist:
    print(item, end=' ')

print('\n我还要买大米。')
shoplist.append('大米')
print('现在我的清单是', shoplist)

print('现在我将要为我的清单排序')
shoplist.sort()
print('排序后的购物清单是', shoplist)

print('我要买的第一个物品是', shoplist[0])
olditem = shoplist[0]
del shoplist[0]
print('我已经买了', olditem)
print('现在我的清单是', shoplist)
```

输出：

```
D:> python using_list.py
我要买 4 个物品。
清单是: 苹果 芒果 胡萝卜 香蕉
我还要买大米。
现在我的清单是 ['苹果', '芒果', '胡萝卜', '香蕉', '大米']
现在我将要为我的清单排序
排序后的购物清单是 ['大米', '胡萝卜', '芒果', '苹果', '香蕉']
我要买的第一个物品是 大米
我已经买了大米
现在我的清单是 ['胡萝卜', '芒果', '苹果', '香蕉']
```

> 注：原文为英文，翻译为中文排序后结果与英文不一致，其后的运行结果也不一样了

它是如何工作的:

变量shoplist是将要去超市的人的一个购物清单。在shoplist中，我们只存储了要买的物品的名字的字符串，你可以向清单中添加包括数字甚至是其它清单的任何对象。

我们也使用了循环for..in遍历清单中的所有条目。到现在为止，你必须认识到一个清单也是一个序列。序列的特性将在后面的章节中讨论。

注意，在print函数中使用end关键字参数，表明输出以一个空格结束而不是通常的换行。

接下来，和前面讨论过的一样，我们使用列表对象的append方法向列表中添加一个项目。然后，我们只把列表简单地传递给print语句，整洁地打印列表的内容，以检查这个条目确实添加到了列表中。

然后，我们使用列表对象的sort方法为列表排序。 这个方法作用到列表本身，并不返回一个修改过的列表，理解这一点很很重要，它不同于对字符串的操作。这也是为什么我们列表是可修改的，而字符串是不可修改的原因。

然后，我们在超市购买了一个物品，我们想把它从购物清单中移除，通过使用del语句来实现。这里，我们提到我们想要移除清单中的哪个物品，del语句为我们将它从清单中移除。我们指定，我们想从清单移除第一项，因此，我们使用del shoplist[0](记住，Python从0开始数数数）。

如果你想知道列表对象定义的所有方法，详见help(list)。

## 元组

元组是用来容纳多个对象。认为它们是类似于列表，但是没有列表给你的广泛功能。元组的一个主要特征是他们是不可变，像字符串，即您不能修改元组。

元组是通过在一对可选的圆括号中，项目之间用逗号分隔来定义的。

元组通常用在，一个语句或一个用户定义的函数能够安全地假设为值的集合，即值的元组，不会改变。

例子 (保存为using_tuple.py):

```
zoo = ('蟒蛇', '大象', '企鹅') # 记住圆括号是可选的
print('动物园中动物有数量有', len(zoo))

new_zoo = '猴子', '骆驼', zoo
print('在新动物园中笼子的数量是', len(new_zoo))
print('在新动物园所有的动物是', new_zoo)
print('从老动物园中带来的动物是', new_zoo[2])
print('从老动物园带来最后的动物是', new_zoo[2][2])
print('在新动物园中动物的数量有', len(new_zoo)-1+len(new_zoo[2]))
```

输出：

```
D:> python using_tuple.py
动物园中动物有数量有 3
在新动物园中笼子的数量是 3
在新动物园所有的动物是 ('猴子', '骆驼', ('蟒蛇', '大象', '企鹅'))
从老动物园中带来的动物是 ('蟒蛇', '大象', '企鹅')
从老动物园带来最后的动物是 企鹅
在新动物园中动物的数量有 5
```

它是如何工作的：

变量zoo指的是一个物品的元组。我们看到len函数可以用来获取元组的长度。这也表明，一个元组同样也是一个(序列)(#序列)。

因为老动物园zoo将要关闭，我们现在将这些动物迁移到一个新的动物园new_zoo。因此，（新动物园）new_zoo的tuple包含一些已经存在的动物以及从老动物园zoo带来的动物。回到现实，请注意，在一个元组中的元组不失去其特性。

就像列表一样，我们可以通过在一对方括号中指定条目的位置，访问元组中的物品。这被称为索引操作符。我们通过指定new_zoo[2]访问新动物园new_zoo中的第三项，通过指定new_zoo[2][2]访问新动物园new_zoo的第三项。一旦理解这个习语，这是非常简单的。

圆括号
> 尽管括号是可选的，我总是使用它们以便使它是一个元组更明显，特别是因为，它避免歧义。例如print(1,2,3)和print( (1,2,3) )`两件不同意思的事情——前者打印3个数，而后者输出一个元组(包含三个数字)。

有0个或1个条目的元组
> 一个空的元组由一对空的括号如myempty = ()组成。 然而，只有一个对象的元组并非如此简单。你必须通过在第一个对象（唯一的一个）后紧跟一个逗号来指定它，这样Python可以区分是一个元组还是一个表达式中一个对象的括号，例如，如果你想定义一个只含一个对象这为2的元组，你必须使用 singleton = (2 , )。

Perl程序员应该注意
> 在一个列表中的列表不会失去其特性，也就是说并不像在Perl中夷为平地。这同样适用于在一个元组中的一个元组，或在一个列表中的元组，或在一个元组中的列表等。就Python而言，他们只是存储在另一个对象中的一个对象。

## 字典

字典就像一个地址簿，在那里你只通过知道他/她的名字，就可以找到地址或联系人详细信息。也就是说，我们使用键*(姓名)与值**(细节)相联系。注意，键必须是独一无二的，就像如果有两个完全相同的名字的人，你无法找到正确的信息。

注意，字典的关键字你只能使用不可变的对象(比如字符串)，你可以使用不可变或可变的对象作为字典的值。这基本上意味着，简单地说，对于键你只能使用简单对象。

在字典中的一对键和值是通过使用冒号指定的，如，d = {key1 : value1, key2 : value2 }。注意，键值对用冒号分隔，彼此之间以逗号分隔，所有这些都是包含在一对大括号中。

记住，在字典中键-值对不以任何方式排序。如果你想要一个特定的顺序，那么你将不得不在使用前自己排序。

你将要使用的字典是dict类的对象或实例。

例子 (保存为 using_dict.py):

```
# 'ab'是英文address　book(地址簿)的首个字母

ab = {  'Swaroop'   : 'swaroop@swaroopch.com',
        'Larry'     : 'larry@wall.org',
        'Matsumoto' : 'matz@ruby-lang.org',
        'Spammer'   : 'spammer@hotmail.com'
    }

print("Swaroop的地址是", ab['Swaroop'])

# 删除一个键-值对
del ab['Spammer']

print('\n地址薄中有 {0} 个联系人\n'.format(len(ab)))

for name, address in ab.items():
    print('联系人 {0} 的地址是 {1}'.format(name, address))

# 添加一个键-值对
ab['Guido'] = 'guido@python.org'

if 'Guido' in ab:
    print("\nGuido的地址是", ab['Guido'])
```

输出：

```
D:> python using_dict.py
Swaroop的地址是 swaroop@swaroopch.com

地址薄中有 3 个联系人

联系人 Larry 的地址是 larry@wall.org
联系人 Matsumoto 的地址是 matz@ruby-lang.org
联系人 Swaroop 的地址是 swaroop@swaroopch.com

Guido的地址是 guido@python.org
```

它是如何工作的：

我们使用已经讨论过的符号创建字典ab。然后我们通过使用在列表和元组中讨论过的索引操作符－－指定关键字来访问键-值对，遵守简单的语法。

我们可以使用我们的老朋友——del语句删除键值对，我们简单地指定字典和要删除的关键字的索引操作符，并将它传递给del语句。对于这个操作，没有必要知道对应于关键字的值。

接下来，我们我们使用字典的items方法，访问字典的每个键-值对的。它返回一个元组的列表，每个元组包含一对值--关键字及紧随其后的值。我们检索这对值并使用for..in循环为每一对分配给相应的变量name和address，然后在for块中打印这些值。

我们可以通过简单地使用索引操作符来访问一个键并分配值的方式添加新的键值对，像上面的例子中我们所做的添加Guido。

我们可以使用in操作符来检查一个键值对是否存在。

字典dict类的列表方法，请看help(dict)。

关键字参数和字典
> 有一点不同需要注意，如果你在您已经在使用字典的函数中使用关键字参数，只是这样想，这个键值对是在函数定义的参数列表中指定的，而当你在函数中访问变量，它只是访问字典的一个键(在编译器设计术语中称为符号表)。

## 序列

列表、元组和字符串都序列的一个实例，但是什么是序列，它们为什么如此特殊呢 ？

主要特点是**成员测试**，即in(在)和not in(不在)表达式中和**索引操作**，这使我们在一个序列中能够直接获取一个特定的对象。

上面提到的——列表、元组和字符串这三种类型的序列，也有允许我们找回一彼序列即序列的一部分的切片操作。

例子 (保存为seq.py):

```
shoplist = ['苹果', '芒果', '胡萝卜', '香蕉']
name = 'swaroop'

# Indexing or 'Subscription' operation
print('第0项是', shoplist[0])
print('第1项是', shoplist[1])
print('第2项是', shoplist[2])
print('第3项是', shoplist[3])
print('第-1项是', shoplist[-1])
print('第-2项是', shoplist[-2])
print('第0个字符是', name[0])

# 一个列表的切片
print('第1项到第3项是', shoplist[1:3])
print('第2项到末尾是', shoplist[2:])
print('第1到-1项是', shoplist[1:-1])
print('开头到结尾是', shoplist[:])

# 字符串的切片
print('第1到第3个字符是', name[1:3])
print('第2到末尾的字符是', name[2:])
print('第1到-1的字符是', name[1:-1])
print('从头到尾的字符是', name[:])
```

输出：

```
D:> python seq.py
第0项是 苹果
第1项是 芒果
第2项是 胡萝卜
第3项是 香蕉
第-1项是 香蕉
第-2项是 胡萝卜
第0个字符是 s
第1项到第3项是 ['芒果', '胡萝卜']
第2项到末尾是 ['胡萝卜', '香蕉']
第1到-1项是 ['芒果', '胡萝卜']
开头到结尾是 ['苹果', '芒果', '胡萝卜', '香蕉']
第1到第3个字符是 wa
第2到末尾的字符是 aroop
第1到-1的字符是 waroo
从头到尾的字符是 swaroop
```

它是如何工作的：

首先，我们看看如何使用索引来获得一个序列的个别项，这也称为订阅操作。当你在方括号中指定一个数字对应一个序列中的某项，如上所示，Python会为你取得序列中相对应位置的项。记住，Python从0开始数数。因此，在序列shoplist中， shoplist[0]取第一项和shoplist[3]获取第四项。

索引也可以是负数，在这种情况下，这个位置从序列的结尾开始计算。因此， shoplist[-1]指的是序列的最后一项， shoplist[-2]取倒数第二个项。

这个切片操作是通过指定序列的名称后面加上一个方括号，方括号中有一对可选的用冒号分隔的数。注意，这非常类似于你到现在一直使用的索引操作，记住这些数字是可选的但冒号不是。

在切片操作中的第一个数字(在冒号前)是切片开始的位置，第二个数字(在冒号后)是切片停止的位置。如果第一个数字没有指定，Python会从序列开头开始，如果第二个数字被冷落，Python会在序列的末尾停止。注意，返回的切片在开始位置开始，在结束位置前结束，也就是说，返回的切片包含开始位置，但不包含结束位置。

因此， shoplist[1:3] 返回序列的切片从位置1开始，包括位置2，但是在位置3停止，因此，返回两个项目的切片。同样，shoplist[:]返回整个序列的一个副本。

你也可以使用负位置做切片。负数用于从序列的结尾开始。例如，shoplist[:-1]` 将返回一个不包括序列最后一项，但包含了其它一切的切片。

你也可以为切片提供第三个参数，这是切片的步长(默认情况下，步长为1)：

```
>>> shoplist = ['苹果', '芒果', '胡萝卜', '香蕉']
>>> shoplist[::1]
['苹果', '芒果', '胡萝卜', '香蕉']
>>> shoplist[::2]
['苹果', '胡萝卜']
>>> shoplist[::3]
['苹果', '香蕉']
>>> shoplist[::-1]
['香蕉', '胡萝卜', '芒果', '苹果']
```

注意，当步长是2时，我们获得位置0、2、……的项目，当步长是3晨，我们获得位置是0、3、等等的项目。

使用Python解释器的交互式提示，尝试指定切片的不同组合，以便你可以立刻看到结果。序列的一大好处是，你可以以同样的方式访问元组、列表和字符串！

## 集合

集合是简单对象的无序集合，用于一个集合中对象的存在比它的顺序或发生多少次更重要的时候。

使用集合，你可以测试成员，它是否是集合的子集以及找到两个集合的交集，等等。

```
>>> bri = set(['巴西', '俄罗斯', '印度'])
>>> '印度' in bri
True
>>> 'usa' in bri
False
>>> bric = bri.copy()
>>> bric.add('中国')
>>> bric.issuperset(bri)
True
>>> bri.remove('俄罗斯')
>>> bri & bric # 或者 bri.intersection(bric)
{'巴西', '印度'}
```

它是如何工作的：

这个例子是非常一目了然的，因为它涉及到学校教的数学的基本集合理论。

## 关联

当你创建一个对象，并赋给它一个值，该变量只是指向对象，并不代表对象本身！也就是说，变量名称指向你电脑中内存中的存储对象的那部分。这就是所谓的把名字绑定给对象。

一般来说，你不需要担心这个，但是对引用有一个需要你注意的微妙的影响。

例子 (保存为reference.py):

```
print('简单的分配')
shoplist = ['苹果', '芒果', '胡萝卜', '香蕉']
mylist = shoplist # mylist是指向同一对象的另一个名字！

del shoplist[0] # 我买到了第一项物品，因此我从清单中移除它

print('shoplist是', shoplist)
print('mylist是', mylist)
# 注意shoplist和mylist都打印没有‘苹果’的相同的清单
# 证明它们指向相同的对象

print('通过制作完整的切片复制')
mylist = shoplist[:] # 通过制作完整的切片复制
del mylist[0] # 移除第一项

print('shoplist是', shoplist)
print('mylist是', mylist)
# 注意，现在两个清单不同
```

输出：

```
D:> python reference.py
简单的分配
shoplist是 ['芒果', '胡萝卜', '香蕉']
mylist是 ['芒果', '胡萝卜', '香蕉']
通过制作完整的切片复制
shoplist是 ['芒果', '胡萝卜', '香蕉']
mylist是 ['胡萝卜', '香蕉']
```

它是如何工作的:

在注释中有更多有用的解释。

记住,如果你想要复制一个列表或这种类型的序列或复杂的对象(而不是简单的对象如整数)，那么您必须使用切片操作复制。如果你只是用另一个变量名指定，两个变量将“关联”到相同的对象，如果你不小心，这可能会引起麻烦。

Per程序员需要注意
> 记住，列表的一个赋值语句并不创建一个副本。你必须使用切片操作复制序列。

## 关于字符串的更多

之前，我们已经详细讨论了字符串。在这能了解更多吗？嗯，你知道吗，字符串也是对象和也有做任何事情的方法－－从检查的部分字符串到从字符串中分离。

在程序中你使用的字符串都是str类的对象，在下面的例子中将演示这个类的一些有用的方法，这些方法的完整列表，请看help(str)。

例子 (保存为 str_methods.py):

```
name = 'Swaroop' # 这是一个字符串对象

if name.startswith('Swa'):
    print('是的，字符串以"Swa"开始')

if 'a' in name:
    print('是的，它包含字符串"a"')

if name.find('war') != -1:
    print('是的，它包含字符串"war"')

delimiter = '_*_'
mylist = ['巴西', '俄罗斯', '印度', '中国']
print(delimiter.join(mylist))
```

输出:

```
D:> python str_methods.py
是的，字符串以"Swa"开始
是的，它包含字符串"a"
是的，它包含字符串"war"
巴西_*_俄罗斯_*_印度_*_中国
```

它是如何工作的：

在这里，我们看到字符串的很多方法在起作用。startswith方法是用来找出字符串是否以给定的字符串开始的。in操作符是用来检查一个给定的字符串是否是一个字符串的一部分。

find方法用于定位给定的子字符串在字符串内的位置，如果不能成功找到子字符串它返回-1。str类也有一个整洁的方法来连接一个序列的字符串，用充当分隔符的字符串连接序列中每个条目，返回一个由它生成的巨大的字符串。

## 小结

我们详细探索了Python各种内建的数据结构，写合理大小的程序，这些数据结构是至关重要的。

现在，我们有很多Python的基本知识已经到位，下面，我们看看如何设计和写一个真实的Python程序。 

## 解决问题

我们已经探索过了Python语言的各种部分，现在我们通过设计和编写一个做有用事情的程序，看一看如何将所有这些组合在一起，学习如何自己编写一个Python脚本可以实现这个想法。

## 问题

我们想要解决的问题是"*我需要一个为我所有重要的程序创建备份的一个程序*"。

尽管这是一个简单的问题，但是我们没有着手解决这个问题的足够的信息。多一点的分析是必需的，例如，我们如何指定哪一个文件需要备份？他们是怎样存储的？

在得当的问题分析后，我们设计我们的程序。我们为程序如何工作列一个列表，在本例中，我创建了我希望它如何工作的以下列表。如果你做这个设计，你可能不会拿出同样的分析，因为每个人都有自己做事的方式，这是非常好的。

* 在列表中指出需要备份的文件和目录。
* 备份必须存储在一个主备份目录中。
* 备份的文件压缩到一个压缩文件中。
* 压缩文件的名称是当前的日期和时间。
* 在标准的 Linux/Unix 发行版上，我们默认使用标准的zip命令，Windows用户可以从GnuWin32项目页 安装，并向你的系统环境变量 PATH追加C:\Program Files\GnuWin32\bin，这和为识别Python命令我们所做的类似。注意，只要它有一个命令行，你可以使用任何你想要归档的命令。

## 解决方案

由于我们的程序的设计现在相当稳定，我们可以写实现解决方案的代码。

保存为backup_ver1.py:

```
import os
import time

# 1. 在列表中指出需要备份的文件和目录。
source = ['"C:\\My Documents"', 'C:\\Code']
# 注意我们在有空格的名字的字符串内不得不使用双引号。

# 2. 备份必须存储在一个主备份目录中。
target_dir = 'E:\\Backup' # 记住把它改为你要使用的目录

# 3. 备份的文件压缩到一个压缩文件中。
# 4. 压缩文件的名称是当前的日期和时间。
target = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'

# 5. 我们使用zip命令把文件压缩到一个压缩文件中
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# 运行备份
if os.system(zip_command) == 0:
    print('成功备份到', target)
else:
    print('备份失败')
```

输出:

```
D:> python backup_ver1.py
成功备份到 E:\Backup\20080702185040.zip
```

现在，我们是在测试我们的程序能否正常工作的**测试**阶段。如果它不像预期的那样,则我们必须**调试**我们的程序，也就是从程序中去掉bug(错误)。

如果上面的程序不为你工作，在os.system调用之前放置一个print(zip_command)，然后运行程序。 现在复制/粘贴print(zip_command)到shell提示符，看看它自己是否正常运行。如果这个命令失败,检查压缩命令手册，是什么可能是错的。如果这个命令成功，然后检查Python程序是否和上面的程序完全匹配。

它是如何工作的：

你会注意到，我们是如何以一个循序渐进的方式将我们的**设计**转换成**代码**的。

我们通过先导入和使用os和time模块，然后，我们在source清单中指定要备份的文件和目录，目标目录存储在变量 target_dir中，是我们要存储的所有的备份文件的地方，我们将要创建的压缩文件的名称是使用 time.strftime() 函数由当前日期和时间生成的。它也包含 .zip扩展名，将存储在target_dir目录中。

注意，变量os.sep的使用--目录的分隔符依你的操作系统而定，即，在Linux和 Unix中是'/'，在Windows中是'\\'，在Mac OS中是':'。使用os.sep而不是直接使用这些字符将使我们的程序更具可移植性，在所有这些系统上都能工作。

time.strftime()函数获取一个技术参数，像在上面的程序中我们已经使用过的。%Y参数将被替换为带着世纪的年份数字。%m参数将被一个位于01到12的数字替换，如此等等。这种参数的完整列表可[Python参考手册](http://docs.python.org/3/library/time.html)中找到。

我们创建目标文件的名称zip文件使用了加法操作符。加法操作符连接字符串，也就是，它将两个字符串连接在一起，并返回一个新的。然后,我们创建一个包含我们要执行的命令的字符串zip_command。你可以通过在shell(Linux终端或DOS提示符)运行来检查这个命令的工作。

我们使用了有一些选项并传递参数的zip命令。-q选项用于表明zip命令应该**quietly(默默地)**工作，-r选项指定zip命令应该**recursively(递归地)**工作，即它应该包括所有的子目录和文件。这两个选项组合在一起可缩写为-qr。要创建的压缩文件名后的选项后面紧跟要备份的文件和目录列表，我们使用字符串的join方法，这种方法我们已经知道如何使用，将source列表转换成一个字符串。

然后，我们终于使用os.system函数运行命令。os.system函数运行命令就仿佛在系统上也就是shell上运行它，如果命令运行成功，它返回0，否则返回一个错误号。

根据命令的结果，我们打印相应的消息，备份失败或成功。

就是这样，我们已经创建了一个备份我们重要文件的一个脚本!

Windows用户应注意
> 您还可以使用原始字符串，而不是双反斜杠转义序列，例如，使用'C:\\Documents'或r'C:\Documents'。然而，**不要**使用'C:\Documents'，因为你最终用一个未知的转义序列\D。
现在，我们有一个能够工作的备份脚本，当我们想要备份文件时，我们可以用它。正如前面所讨论的，建议Linux/Unix用户使用(可执行方式)(#可执行的python程序)，这样他们可以随时随地运行备份脚本。这被称为软件的**操作**阶段或**部署**阶段。

上面的程序正常工作，但(通常)第一个程序不会像你期望的那么样工作。例如，如果没有正确地设计程序或当键入代码时如果你犯了一个错误等，可能出现问题。相应地，你将不得不回到设计阶段或你需要调试您的程序。

## 第二版

第一个版本的脚本工作了。然而，我们还可以做一些改进，以便每天工作得更好。这被称为软件的维护阶段。

我觉得有用的改进之一是有一个更好的文件命名机制——在一个目录中，使用时间作为文件的名称，使用当前日期作为主备份目录中的一个目录。第一个优势是，你的备份以分层以方式存储，因此它更容易管理。第二个优势是，文件名短得多。第三个优势是单独的目录将帮助你检查每天是否创建了一个备份，如果某一天你备份了，将会创建一个目录。

保存为 backup_ver2.py:

```
import os
import time

# 1. 在列表中指出需要备份的文件和目录。
source = ['"C:\\My Documents"', 'C:\\Code']
# 注意，因为名字字符串中有空格，我们不得不使用双引号。

# 2. 备份必须存储在一个主备份目录中。
target_dir = 'E:\\Backup' # 记住把它改为你要使用的目录

# 3. 备份的文件压缩到一个压缩文件中。
# 4. 当前日期是主备份目录中子目录的名字
today = target_dir + os.sep + time.strftime('%Y%m%d')
# 当前时间是压缩文件的名字
now = time.strftime('%H%M%S')

# 如果子目录不存在，创建它
if not os.path.exists(today):
    os.mkdir(today) # 建立目录
    print('成功创建目录', today)

# 压缩文件的名字
target = today + os.sep + now + '.zip'

# 5. 我们使用zip命令把文件压缩到一个压缩文件中
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# 运行备份
if os.system(zip_command) == 0:
    print('成功备份到', target)
else:
    print('备份失败')
```

输出：

```
D:> python backup_ver2.py
成功创建目录 E:\Backup\20080702
成功备份到 E:\Backup\20080702\202311.zip

D:> python backup_ver2.py
成功备份到 E:\Backup\20080702\202325.zip
```

它是如何工作的:

大部分程序还保留了原样，变化是，我们使用os.path.exists函数检查在主备份目录中是否存在以当前日期为名字的目录，如果不存在，我们使用os.mkdir函数创建它。

## 第三版

当我们做一些备份时，第二版工作起来很好了。但当有许多备份时，我发现区分为什么备份是很困难的。例如，对一个程序或描述做一些重要的改变，然后我想知道这些变化与压缩文件的名字有什么联系。这个可以通过为压缩文件的名字附加上一个用户提供的注释而轻易实现。

注意
> 下面的程序不工作，所以不要惊慌，请继续，因为在这里有一个教训。
保存为 backup_ver3.py:

```
import os
import time

# 1.  在列表中指出需要备份的文件和目录。
source = ['"C:\\My Documents"', 'C:\\Code']
# 注意，因为名字字符串中有空格，我们不得不使用双引号。

# 2. 备份必须存储在一个主备份目录中。
target_dir = 'E:\\Backup' # 记住把它改为你要使用的目录

# 3. 备份的文件压缩到一个压缩文件中。
# 4. 当前日期是主备份目录中子目录的名字
today = target_dir + os.sep + time.strftime('%Y%m%d')
# 当前时间是压缩文件的名字
now = time.strftime('%H%M%S')

# 为创建一个压缩文件的名字从用户取得一个注释
comment = input('Enter a comment --> ')
if len(comment) == 0: # 检查是否输入注释
    target = today + os.sep + now + '.zip'
else:
    target = today + os.sep + now + '_' +
        comment.replace(' ', '_') + '.zip'

# 如果子目录不存在，创建它
if not os.path.exists(today):
    os.mkdir(today) # 建立目录
    print('成功创建目录', today)

# 5. 我们使用zip命令把文件压缩到一个压缩文件中
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# 运行备份
if os.system(zip_command) == 0:
    print('成功备份到', target)
else:
    print('备份失败')
```

输出：

```
D:> python backup_ver3.py
  File "backup_ver3.py", line 25
    target = today + os.sep + now + '_' +
                                        ^
SyntaxError: invalid syntax
```

这怎么（不）工作：

**这个程序不工作！**Python说有语法错误这意味着脚本不满足Python预计的结构。当我们观察Python给出的错误，它还告诉我们它检测到错误的地方。所以我们从那一行开始调试我们的程序。

在仔细观察后，我们发现单一的逻辑行被分成两个物理行，但我们没有指定这两个物理行属于同一个逻辑行。基本上，Python发现在那个逻辑行添加操作符(+)没有任何操作对象，因此不知道如何继续。记住，我们可以通过在物理行的结束位置使用反斜杠指定当前行与下一物理行是连续的。所以，我们要改正我们的程序。我们找到错误时的这样修正叫做修复bug。

## 第四版

保存为 backup_ver4.py:

```
import os
import time

# 1. 在列表中指出需要备份的文件和目录。
source = ['"C:\\My Documents"', 'C:\\Code']
# 注意，因为名字字符串中有空格，我们不得不使用双引号。

# 2. 备份必须存储在一个主备份目录中。
target_dir = 'E:\\Backup' #记住把它改为你要使用的目录

# 3. 备份的文件压缩到一个压缩文件中。
# 4. 当前日期是主备份目录中子目录的名字
today = target_dir + os.sep + time.strftime('%Y%m%d')
# 当前时间是压缩文件的名字
now = time.strftime('%H%M%S')

# 为创建一个压缩文件的名字从用户取得一个注释
comment = input('输入注释--> ')
if len(comment) == 0: # 检查是否输入注释
    target = today + os.sep + now + '.zip'
else:
    target = today + os.sep + now + '_' + \
        comment.replace(' ', '_') + '.zip'

# 如果子目录不存在，创建它
if not os.path.exists(today):
    os.mkdir(today) #  建立目录
    print('成功创建目录', today)

# 5. 我们使用zip命令把文件压缩到一个压缩文件中
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# 运行备份
if os.system(zip_command) == 0:
    print('成功备份到 ', target)
else:
    print('备份失败')
```

输出：

```
D:> python3 backup_ver4.py
输入注释--> added new examples
成功备份到 E:\Backup\20080702\202836_added_new_examples.zip

D:> python3 backup_ver4.py
输入注释-->
成功备份到 E:\Backup\20080702\202839.zip
```

它是如何工作的：

这个程序现在工作了！让我们仔细检查第三版的实际增强，我们使用input函数获取 用户的注解，然后通过使用len函数找到输入的长度检查用户确实输入了一些东西。如果用户只是按enter（回车键），没有输入任何东西(也许这只是一个常规备份或没有特殊的改变)，那么，我们按照我们之前所做的处理。

然而，如果提供了一个注释，那么，它将附加到压缩文档名字中、 .zip扩展名前。请注意，我们将注释中的空格用开线正在取代空间在评论中用下划线——这是因为管理没有空格的文件名容易得多。

## 更细化

第四版对于大多数用户来说是一个令人满意的工作脚本，但总有改进的余地。例如，您可以为程序包括一个冗长级别，在那里你可以指定一个-v选项，从而使你的程序变得更加健谈。

另一个可能的优化处理是将允许额外的文件和目录被传递给该脚本的命令行。我们可从sys.argv列表得到这些文件名，我们可以使用list类提供的extend方法将它们添加到我们的source列表中。

最重要的改进是不使用的创建文档的os.system 方式，而是使用转而使用内建的 zipfile 或 tarfile模块创建文档。他们是标准库的一部分，在你的计算机上已经为您提供使用没有外部依赖的压缩程序。

然而，在上面的例子中，纯粹是为教学的目的，我一直使用 os.system的方式创建一个备份，这样的例子对每个人的理解足够简单，但不是真正足够的有效。

你能使用[zipfile(压缩文件)](http://docs.python.org/3/library/zipfile.html)模块，而不是os.system调用尝试写第五版吗？

## 软件开发过程

我们已经经历了编写一个软件过程中的各种阶段。这些阶段可以概括如下：

1. 什么 (分析)
2. 怎样 (设计)
3. 做 (实现)
4. 测试 (测试和调试)
5. 使用 (操作和部署)
6. 维护 (优化)
编写程序的推荐方法是我们创建备份脚本的过程：做了分析和设计，开始实现用一个简单的版本，测试和调试它，来确保它能按预期工作。现在，添加你想要的任何功能，继续重复需要次数的做－试验循环。记住，**软件是在成长，而不是建立**。

## 小结

我们已经看到了如何创建我们自己的Python程序/脚本和编写这种程序的不同阶段。你可能会发现创建你自己的程序就像我们在这一章做的是有用的，以便你熟悉Python以及解决问题。

接下来，我们将讨论面向对象编程。 

## 面向对象编程

到现在为止，在我们编写的所有程序中，我们围绕着函数，也就是处理数据的语句块来设计我们的程序，这叫做*面向过程*的编程方式，还有一种组织你的程序的方式，是将数据和函数组合起来打包到称为对象的东西里面，这叫做*面向对象*编程技术。大多数情况下，你可以使用面向过程的编程方式，但当你编写大型程序或者有一些适用于这种方式更好的问题时，你可以使用面向对象的编程技术。

类和对象是面向对象编程的两个主要方面，一个类创建一个新的类型，在这里对象是类的一个实例。一个比喻，你可以有int型变量，换句话说，存储整数的变量是int类的一个实例（对象）。

静态语言的程序员应该注意
> 注意，整数甚至被看作（int类的)对象。这不像在C++和(1.5版本以前的)Java语言中整数是原始的原生数据类型，关于类的更多细节，请看help(int)。

C#和Java程序员将发现这和*装箱*和*拆封*的概念相似。

对象可以使用属于对象的普通变量存储数据。属于一个对象或类的对象被称为**字段**。对象也可以通过使用属于类的函数有函数性。这样的函数被称为类的**方法**，这个术语是很重要的，因为它帮助我们区分函数和变量哪些是独立的，那些是属于一个类或对象的。总体而言，这些字段和方法可以被称为**类**的属性。

字段有两种类型，它们可以属于类的每个实例/对象，或属于类本身。它们被分别称为**实例变量**和**类变量**。

要创建一个类使用class的关键字，类的字段和方法在一个缩进块中列出。

## 自我

类的方法与普通的函数只有一个特别的不同点--他们必须有一个额外的第一个名字、必须被添加到参数列表的开始处，但你调用该方法时，**不用**给此参数的值，Python将提供它。这个特别的变量指向对象本身，按照惯例，它的名字是self。

虽然,你可以给这个参数任何名字，强烈推荐你使用名称self --任何其他的名字肯定是不清楚的。使用标准的名字，有许多优势--你的程序的任何读者将立即认出它，如果你使用self，甚至专门的ide(集成开发环境)也可以帮助你。

C++/Java/C#程序员要注意
> 在Python中，self相当于C++中的指针this、Java和C#中的this引用。

你一定很想知道Python怎样给self赋值，为什么你不需要给它一个值。一个例子会使这个清楚。假设，你有一个称为MyClass的类和这个类的实例称为myobject。当你调用这个对象的方法myobject.method(arg1, arg2)时，Python将自动转换成MyClass.method(myobject, arg1, arg2)--这是关于self的所有特殊之处。

这也意味着,如果你有一个不带任何参数的方法，那么你还得有一个参数——self。

类

最简单的类可能是如下面的示例所示(另存为simplestclass.py).

```
class Person:
    pass # 一个空块

p = Person()
print(p)
```

输出：

```
D:> python3 simplestclass.py
<__main__.Person object at 0x019F85F0>
```

它是如何工作的：

我们使用的类的声明和类的名称创建一个新的类，接下来是形成类的主体语句的一个缩进块。在这里，我们使用pass语句表示这是一个空的块。

接下来，我们使用类名后跟一对圆括号创建这个类的一个对象/实例(在接下来的部分，我们将学习更多关于实例化的知识)。为了验证，我们通过简单地打印它确认变量的类型。它告诉我们，在__main__模块中有一个Person类的实例。

注意，你的对象存储在计算机内存的地址也被打印了。因为Python找到任何地址就存储对象，因而，在你的计算机上地址会有所不同。

## 对象的方法

我们已经讨论了类/对象除了有额外的self变量外，还可以有方法，就像函数。现在,我们将看到一个例子(另存为”的方法py”)。

```
class Person:
    def sayHi(self):
        print('嗨，你好吗？')

p = Person()
p.sayHi()
# 这个小例子也可写成Person().sayHi()
```

输出：

```
D:> python method.py
嗨，你好吗？
```

它是如何工作的：

在这里我们看到self在起作用。注意， sayHi方法不包含任何参数，但在函数定义中仍有 self。

## init 方法

在Python中有许多特别重要的方法名称，现在，我们看看__init__方法的重要性。

类的一个对象一被初始化， __init__方法就运行。这个方法对你的对象做任何初始化都是有用的。

例子 (保存为 class_init.py):

```
class Person:
    def __init__(self, name):
        self.name = name
    def sayHi(self):
        print('嗨，我的名字是', self.name)

p = Person('Swaroop')
p.sayHi()

# 这个小程序也可以写成 Person('Swaroop').sayHi()
```

输出：

```
D:> python class_init.py 嗨，我的名字是 Swaroop
```

它是如何工作的：

在这里，我们定义一个带参数name(和通常的 self)的__init__方法。在这里，我们只是创建一个新的称作name的字段。注意，尽管它们都叫 name，但它们是两个不同的变量。因为self.name中的点符号意味着"self"对象的一部分有个叫"name" 的东西，而另一个"name"是一个局部变量,因此没有问题。因为我们明确地表明我们所指的是哪个的名字，没有混乱。

最重要的是。请注意。我们没有显式地调用 __init__ 方法，而是当创建类的一个实例时，通过在类名称后的括号内传递参数，这是该方法的特殊意义。

现在，我们可以在我们的方法中使用self.name字段了，在sayHi方法中已经做了演示。

## 类和对象的变量

我们已经讨论了类与对象的部分功能(即方法)，现在让我们了解一下数据部分。数据部分，即字段，只不过是被绑定到对象和类的空间名字的普通变量。这意味着，这些名字只有在类和对象的环境内有效。这就是为什么他们被叫做空间名字的原因。

有两种类型的字段--类变量和对象变量，它们的分类取决于类和对象分别属于哪种变量。

*类变量*是共享的——他们可以被该类的所有实例访问。类变量只是一个拷贝，当任何一个对象改变一个类变量时，所有的其它实例都将改变。

*对象变量*是类的每个对象或实例所特有的。既然这样，每个对象都有自己的字段拷贝，也就是说，在不同的实例中，它们不共享，同名的字段没有任何联系。一个例子能使你容易理解（保存为objvar.py):

```
class Robot:
    '''表示人一机器人，有一个名字。'''

    # 一个类变量，数机器人的数量
    population = 0
 
    def __init__(self, name):
        '''初始化数据。'''
        self.name = name
        print('(初始化 {0})'.format(self.name))
 
        # 当创建一个人时，机器人
        # 人口加1
        Robot.population += 1
 
    def __del__(self):
        '''我将要死了。'''
        print('{0} 正在被毁！'.format(self.name))
 
        Robot.population -= 1
 
        if Robot.population == 0:
            print('{0}是最后一个。'.format(self.name))
        else:
            print('还有{0:d}机器人在工作。'.format(Robot.population))
 
    def sayHi(self):
        '''机器人问候。
 
        是的，它们能做作那个。'''
        print('你好，我的主人叫我'.format(self.name))

    def howMany():
        '''打印当前人口。'''
        print('我们有{0:d}个机器人。'.format(Robot.population))
    howMany = staticmethod(howMany)
 
droid1 = Robot('R2-D2')
droid1.sayHi()
Robot.howMany()
 
droid2 = Robot('C-3PO')
droid2.sayHi()
Robot.howMany()
 
print("\n机器人在这能做一些工作。\n")

print("机器人已经完成了它们的工作，因此，让我们销毁它们。")
del droid1
del droid2

Robot.howMany()
```

输出：

```
D:> python objvar.py
(初始化 R2-D2)
你好，我的主人叫我
我们有1个机器人。
(初始化 C-3PO)
你好，我的主人叫我
我们有2个机器人。

机器人在这能做一些工作。

机器人已经完成了它们的工作，因此，让我们销毁它们。
R2-D2 正在被毁！
还有1机器人在工作。
C-3PO 正在被毁！
C-3PO是最后一个。
我们有0个机器人。
```

它是如何工作的：

这是一个很长的例子，但有助于展示类和对象变量的特性。在这里，population 属于Robot类，因此是一个类变量。name变量属于对象(使用self分配)，因此是一个对象变量。

因此，我们提到population类变量使用Robot.population 而不是self.population。我们在那个对象的中提到对象变量name使用self.name符号。记住对象和类变量的简单区别。还请注意，一个对象变量与一个类变量名字相同时，类变量将被隐藏！

howMany实际上是一个属于类而不是对象的方法，这意味着我们可以将其定义成 classmethod 或staticmethod中的任何一个，这取决于我们是否需要知道是哪个类。因为，我们不需要这样的信息，我们主张staticmethod 。

我们也可以使用(decorator)(http://www.ibm.com/developerworks/linux/library/l-cpdecor.html)达到同样的目的：

```
@staticmethod
def howMany():
    '''打印当前人口。'''
    print('我们有{0:d}个机器人。'.format(Robot.population))
```

修饰符可以被想象为一个调用显式声明的捷径，正如我们在这个例子中已经看到的。

注意到，__init__方法用于使用一个名字初始化 Robot 实例。在这个方法中，因为还有一个机器人被添加,我们为population计数加了1。还发现，self.name的值是针对每一个对象的，这表明对象变量的特性。

记住,你必须只有使用self引用同一对象的变量和方法，这就是所谓的属性引用。

在这个程序中,我们也看到了类和方法的**文档字符串**的用法。在运行时我们可能通过使用Robot.__doc__访问类的文档字符串，使用 Robot.sayHi.__doc__ 访问方法的为文档字符串。

就像__init__方法一样，还有一个特殊的方法__del__ ，该方法是在当对象将要毁灭时被调用，也就是说它不再被使用、能够为计算机系统释放出被它使用的内存。在这个方法中，我们简单地给 Robot.population 减1。

del`方法在对象不再使用时使用，当这个方法被运行时没有保证。如果你想明确地看到它在起作用，我们所能做的是必须使用del语句。

所有的类成员是公共的，一个例外是：如果你使用的数据成员的名字使用了双下划线前缀如__privatevar, Python使用名称改编来有效地使它成为一个私有变量。

因此,下面的惯例是，只在对象和类中使用的任何变量，首先应该以一个下划线开始，其他所有的名字都是公共的，且可以被用于其他的类/对象使用。记住，这只是一个惯例和不是被Python强制执行的(除了双下划线前缀)。

C++/Java/C#程序员要注意
> 在Python中，所有类成员(包括数据成员)是公共有和所有的方法是虚拟。

## 继承

面向对象编程的一个好处是代码的重用，一种方式是通过继承机制实现，继承可以被想像为实现类之间的一种类型和子类型的关系。

假设您想编写一个大学里教师和学生记录的程序，他们有一些共同的特性，如姓名、年龄和地址。他们也有特定的特性，如老师的工资、课程和树叶和学生的学费、分数。

您可以为每个类型创建两个独立的类，并且处理它们，但要添加一个新的共同特征意味着要在这两种独立的类中都要添加，很快就会变得难以处理。

一个更好的方法是创建一个共同的类称为 SchoolMember ，然后从这个类继承老师类和学生类，也就是说它们成为这个类的子类，可以对这些子类添加特定的特征。

这种方式有很多优点，如果我们在SchoolMember中添加/更改任何功能，在子类中会自动反映出来。例如，您可以为学生和老师添加一个新的身份证字段，可能通过直接把它们添加到SchoolMember类中来实现。然而，子类中的变化不影响其他子类。另一个优点是，如果你引用SchoolMember类的一个老师或学生对象，在某些情况下如计算学校成员的数量时会很有用。这就是所谓的**多态性**，如果父类是预期的，子类在任何情况下可以被取代，即对象可以当做父类的一个实例。

还观察到，我们重用父类的代码，在不同的类中我们不需要重复，而在使用独立的类的情况下我们不得不重复。

在这种情况下，SchoolMember类被称为*基类*或*超类*。Teacher和Student类被称为*派生类*或*子类*。

现在，我们将看到作为程序的这个例子(保存为 inherit.py)：

···
class SchoolMember:
    '''代表任何学校成员。'''
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print('(初始化学校成员： {0})'.format(self.name))
    
    def tell(self):
        '''告诉我细节。'''
        print('Name:"{0}" Age:"{1}"'.format(self.name, self.age), end=" ")

class Teacher(SchoolMember):
    '''代表老师。'''
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary = salary
        print('(初始化老师： {0})'.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print('Salary: "{0:d}"'.format(self.salary))

class Student(SchoolMember):
    '''代表学生。'''
    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks = marks
        print('(初始化学生： {0})'.format(self.name))
    
    def tell(self):
        SchoolMember.tell(self)
        print('Marks: "{0:d}"'.format(self.marks))

t = Teacher('Mrs. Shrividya', 40, 30000)
s = Student('Swaroop', 25, 75)

print() # 打印一个空行

members = [t, s]
for member in members:
    member.tell() # 为Teachers和Students工作
···

输出：

```
D:> python inherit.py
(初始化学校成员： Mrs. Shrividya)
(初始化老师： Mrs. Shrividya)
(初始化学校成员： Swaroop)
(初始化学生： Swaroop)

Name:"Mrs. Shrividya" Age:"40" Salary: "30000" Name:"Swaroop" Age:"25" Marks: "75"~
```

它是如何工作的：

使用继承，在类定义中，在类的名称后，我们在元组中指定基类名称，接下来，我们观察到使用 self变量，显式地调用基类的 __init__方法，这样我们可以初始化对象的基类部分。这是非常重要的，记住——Python不会自动调用基类的构造函数，您自己必须显式地调用它。

我们还观察到，我们可以在类名前加前缀调用基类的方法，然后和其它参数一道传递给 self变量值。

注意，当我们使用SchoolMember类的tell方法时，我们可以把Teacher或Student的实例作为SchoolMember的实例。

同时，观察到子类的tell方法的调用，不是SchoolMember类的tell方法。要理解这一点的一种方法是，Python 总是在实际的类型中开始寻找方法，如本例。如果它不能找到方法，它开始按在类定义中元组中指定的顺序一个接一个地查找属于它的基类的方法。

术语提示--如果在继承元组中不止列出一个类，那么它被称为*多重继承*。

在tell()方法中，end参数是用于来将换行变为在 print()调用结束后以空格开始。

## 小结

我们已经探讨了类和对象的各个方面以及与之关联的各种术语。我们也看到了面向对象编程的好处和缺陷。Python是高度面向对象，从长远看仔细理解这些概念仔细将对你很有帮助。

接下，我们将学习如何处理输入/输出和如何在Python中访问文件。

## 输入 输出

会有这种情况，你的程序必须与用户进行交互。例如，你想获取来自用户的输入，然后打印一些返回的结果。我们可以分别使用input()和print()函数来实现。

对于输出，我们还可以使用str(字符串)类的各种方法。例如，您可以使用rjust方法来获取一个指定宽度的字符串。更多细节，见 help(str)。

另一个常见的输入/输出类型是处理文件。创建、读和写文件是许多程序至关重要的，我们将在本章探讨这方面。

## 用户输入

将这个程序保存为 user_input.py:

```
def reverse(text):
    return text[::-1]

def is_palindrome(text):
    return text == reverse(text)

something = input('输入文本： ')
if (is_palindrome(something)):
    print("是的，这是回文")
else:
    print("不，这不是回文")
```

输出：

```
输入文本： 蜜蜂
不，这不是回文
输入文本： 人上人
是的，这是回文
```

它是如何工作的：

我们使用切片特性来颠倒文本。我们已经看到使用seq[a:b]代码获取从a到b来自序列的切片。我们还可以提供一个第三个确定步长的参数，切片默认的步长是 1，它返回一个连续文本的一部分。给一个负的步长，即 -1 ，将以反向返回文本。

input()函数将一个字符串作为参数，并显示给用户。然后等待用户输入和按回车键。一旦用户输入和按下回车键，input()函数将返回用户输入的文本。

我们获取文本并颠倒它。如果原始文本和颠倒的文本是相等的，那么那个文本是一个回文。

家庭作业
> 检查一个文本是否是一个回文应该忽略标点符号、空格和案例。例如，"Rise to vote, sir." 也是一个回文，但我们当前的程序并没有说它是。你能改善上述程序来识别这个回文吗?

下面的提示(不要读)
> 使用一个元组(从这里(http://grammar.ccc.commnet.edu/grammar/marks/marks.htm)你可以找到所有标点符号的一个列表)来保存所有的禁止字符，然后使用会员测试，以确定是否应该删除一个字符，即forbidden = ('!', '?', '.', ...)。

## 文件

为了读写，你可以通过创建一个file类的对象，分别使用read、readline或 write方法来，打开和使用文件。能够读取或写入文件取决于文件打开时指定的模式。最后，当你完成对文件的操作时，你要调用close方法告诉Python，文件我们使用完了。

例子 (保存为 using_file.py):

```
poem = '''\
当工作完成时
编程是有趣的
如果想让你的工作有趣
    使用Python！
'''
 
f = open('poem.txt', 'w') # 为'写w'打开文件
f.write(poem) # 文本写入文件
f.close() # 关闭文件
 
f = open('poem.txt') # 如果不指定打开模式，默认为'读'
while True:
    line = f.readline()
    if len(line) == 0: # 0长度表示文件结尾
        break
    print(line, end='')
f.close() # 关闭文件
```

输出：

```
D:> python using_file.py
当工作完成时
编程是有趣的
如果想让你的工作有趣
    使用Python！
```

它是如何工作的：

首先，通过内置的函数open，指定文件名和我们要打开的模式，打开一个文件。模式可以是读模式('r'), 写模式('w')或追加模式('a')。我们也可以指定是否以文本格式('t') 或二进制格式('b')读,写或追加。实际上有更多可用的模式，help(open) 会给你更多的细节。默认情况下，open()认为是一个以读方式打开的文本格式的文件。

在我们的例子中，我们首先以写文本格式打开文件，使用文件对象的write方法写文件，然后,我们最后 close(关闭)文件。

接下来，为再次阅读，我们打开同一个文件。我们不需要指定一个模式,因为 '读文本文件' 是默认的模式。我们使用readline方法在一个循环中每次读文件的一行。该方法返回一个完整的行，包括换行符结束时的行。当返回一个空字符串时，这意味着我们已经到达文件的末尾，我们'打破'循环。

在默认情况下，print()函数在屏幕上自动换行打印文本。我们是通过指定end=''禁止产生新行，因为从文件读取的行在结尾已经包含一个换行符。然后，我们最终close文件。

现在，检查poem.txt的内容，确认程序确实写入和从那个文件读取。

## 拾取

Python提供了一个标准的模块称为pickle，使用它你可以在一个文件中存储**任何**的Python对象，然后把它弄回来后，这就是所谓的持续的存储对象。

例子 (保存为 pickling.py):

```
import pickle
 
# 我们将要存储对象的文件名
shoplistfile = 'shoplist.data'
# 购物清单
shoplist = ['苹果', '芒果', '胡萝卜']
 
# 定到文件
f = open(shoplistfile, 'wb')
pickle.dump(shoplist, f) # 把对象倒入一个文件
f.close()
 
del shoplist # 释放shoplist变量
 
# 从仓库读回
f = open(shoplistfile, 'rb')
storedlist = pickle.load(f) # 从文件载入对象
print(storedlist)
```

输出：

```
D:> python pickling.py
['苹果', '芒果', '胡萝卜']
```

它是如何工作的：

要在文件中存储一个对象，我们首先必须以'w'rite写'b'inary 二进制格式的方式open打开文件，然后调用pickle模块的dump函数，这个过程叫拾取。

接下来，我们使用pickle模块的load函数取回对象，这个过程叫做拆开。

## 小结

我们已经讨论了各种类型的输入/输出，文件处理和使用pickle模块。

接下来，我们将探讨索异常的概念。


--------------------------------------------------

### 继续阅读[异常](a-byte-of-python3/exception)